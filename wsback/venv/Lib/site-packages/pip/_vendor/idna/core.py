<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
import bisect
import re
import unicodedata
from typing import Optional, Union

from . import idnadata
from .intranges import intranges_contain

_virama_combining_class = 9
_alabel_prefix = b"xn--"
_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")


class IDNAError(UnicodeError):
    """Base exception for all IDNA-encoding related problems"""

=======
=======
>>>>>>> doua
from . import idnadata
=======
>>>>>>> doua
import bisect
import re
import unicodedata
from typing import Optional, Union

from . import idnadata
from .intranges import intranges_contain

_virama_combining_class = 9
_alabel_prefix = b"xn--"
_unicode_dots_re = re.compile("[\u002e\u3002\uff0e\uff61]")


class IDNAError(UnicodeError):
<<<<<<< HEAD
    """ Base exception for all IDNA-encoding related problems """
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
    """Base exception for all IDNA-encoding related problems"""

>>>>>>> doua
    pass


class IDNABidiError(IDNAError):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    """Exception when bidirectional requirements are not satisfied"""

=======
    """ Exception when bidirectional requirements are not satisfied """
>>>>>>> Stashed changes
=======
    """ Exception when bidirectional requirements are not satisfied """
>>>>>>> doua
=======
    """Exception when bidirectional requirements are not satisfied"""

>>>>>>> doua
    pass


class InvalidCodepoint(IDNAError):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    """Exception when a disallowed or unallocated codepoint is used"""

=======
    """ Exception when a disallowed or unallocated codepoint is used """
>>>>>>> Stashed changes
=======
    """ Exception when a disallowed or unallocated codepoint is used """
>>>>>>> doua
=======
    """Exception when a disallowed or unallocated codepoint is used"""

>>>>>>> doua
    pass


class InvalidCodepointContext(IDNAError):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    """Exception when the codepoint is not valid in the context it is used"""

=======
    """ Exception when the codepoint is not valid in the context it is used """
>>>>>>> Stashed changes
=======
    """ Exception when the codepoint is not valid in the context it is used """
>>>>>>> doua
=======
    """Exception when the codepoint is not valid in the context it is used"""

>>>>>>> doua
    pass


def _combining_class(cp: int) -> int:
    v = unicodedata.combining(chr(cp))
    if v == 0:
        if not unicodedata.name(chr(cp)):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
            raise ValueError("Unknown character in unicodedata")
    return v


def _is_script(cp: str, script: str) -> bool:
    return intranges_contain(ord(cp), idnadata.scripts[script])


def _punycode(s: str) -> bytes:
    return s.encode("punycode")


def _unot(s: int) -> str:
    return "U+{:04X}".format(s)
=======
=======
>>>>>>> doua
            raise ValueError('Unknown character in unicodedata')
=======
            raise ValueError("Unknown character in unicodedata")
>>>>>>> doua
    return v


def _is_script(cp: str, script: str) -> bool:
    return intranges_contain(ord(cp), idnadata.scripts[script])


def _punycode(s: str) -> bytes:
    return s.encode("punycode")


def _unot(s: int) -> str:
<<<<<<< HEAD
    return 'U+{:04X}'.format(s)
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
    return "U+{:04X}".format(s)
>>>>>>> doua


def valid_label_length(label: Union[bytes, str]) -> bool:
    if len(label) > 63:
        return False
    return True


def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:
    if len(label) > (254 if trailing_dot else 253):
        return False
    return True


def check_bidi(label: str, check_ltr: bool = False) -> bool:
    # Bidi rules should only be applied if string contains RTL characters
    bidi_label = False
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    for idx, cp in enumerate(label, 1):
        direction = unicodedata.bidirectional(cp)
        if direction == "":
            # String likely comes from a newer version of Unicode
            raise IDNABidiError("Unknown directionality in label {} at position {}".format(repr(label), idx))
        if direction in ["R", "AL", "AN"]:
=======
=======
>>>>>>> doua
    for (idx, cp) in enumerate(label, 1):
=======
    for idx, cp in enumerate(label, 1):
>>>>>>> doua
        direction = unicodedata.bidirectional(cp)
        if direction == "":
            # String likely comes from a newer version of Unicode
<<<<<<< HEAD
            raise IDNABidiError('Unknown directionality in label {} at position {}'.format(repr(label), idx))
        if direction in ['R', 'AL', 'AN']:
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
            raise IDNABidiError("Unknown directionality in label {} at position {}".format(repr(label), idx))
        if direction in ["R", "AL", "AN"]:
>>>>>>> doua
            bidi_label = True
    if not bidi_label and not check_ltr:
        return True

    # Bidi rule 1
    direction = unicodedata.bidirectional(label[0])
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    if direction in ["R", "AL"]:
        rtl = True
    elif direction == "L":
        rtl = False
    else:
        raise IDNABidiError("First codepoint in label {} must be directionality L, R or AL".format(repr(label)))

    valid_ending = False
    number_type: Optional[str] = None
    for idx, cp in enumerate(label, 1):
=======
=======
>>>>>>> doua
    if direction in ['R', 'AL']:
=======
    if direction in ["R", "AL"]:
>>>>>>> doua
        rtl = True
    elif direction == "L":
        rtl = False
    else:
        raise IDNABidiError("First codepoint in label {} must be directionality L, R or AL".format(repr(label)))

    valid_ending = False
<<<<<<< HEAD
    number_type = None  # type: Optional[str]
    for (idx, cp) in enumerate(label, 1):
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
    number_type: Optional[str] = None
    for idx, cp in enumerate(label, 1):
>>>>>>> doua
        direction = unicodedata.bidirectional(cp)

        if rtl:
            # Bidi rule 2
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
=======
>>>>>>> doua
            if direction not in [
                "R",
                "AL",
                "AN",
                "EN",
                "ES",
                "CS",
                "ET",
                "ON",
                "BN",
                "NSM",
            ]:
                raise IDNABidiError("Invalid direction for codepoint at position {} in a right-to-left label".format(idx))
<<<<<<< HEAD
            # Bidi rule 3
            if direction in ["R", "AL", "EN", "AN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False
            # Bidi rule 4
            if direction in ["AN", "EN"]:
=======
=======
>>>>>>> doua
            if not direction in ['R', 'AL', 'AN', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:
                raise IDNABidiError('Invalid direction for codepoint at position {} in a right-to-left label'.format(idx))
=======
>>>>>>> doua
            # Bidi rule 3
            if direction in ["R", "AL", "EN", "AN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False
            # Bidi rule 4
<<<<<<< HEAD
            if direction in ['AN', 'EN']:
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
            if direction in ["AN", "EN"]:
>>>>>>> doua
                if not number_type:
                    number_type = direction
                else:
                    if number_type != direction:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
                        raise IDNABidiError("Can not mix numeral types in a right-to-left label")
        else:
            # Bidi rule 5
            if direction not in ["L", "EN", "ES", "CS", "ET", "ON", "BN", "NSM"]:
                raise IDNABidiError("Invalid direction for codepoint at position {} in a left-to-right label".format(idx))
            # Bidi rule 6
            if direction in ["L", "EN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False

    if not valid_ending:
        raise IDNABidiError("Label ends with illegal codepoint directionality")
=======
=======
>>>>>>> doua
                        raise IDNABidiError('Can not mix numeral types in a right-to-left label')
=======
                        raise IDNABidiError("Can not mix numeral types in a right-to-left label")
>>>>>>> doua
        else:
            # Bidi rule 5
            if direction not in ["L", "EN", "ES", "CS", "ET", "ON", "BN", "NSM"]:
                raise IDNABidiError("Invalid direction for codepoint at position {} in a left-to-right label".format(idx))
            # Bidi rule 6
            if direction in ["L", "EN"]:
                valid_ending = True
            elif direction != "NSM":
                valid_ending = False

    if not valid_ending:
<<<<<<< HEAD
        raise IDNABidiError('Label ends with illegal codepoint directionality')
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
        raise IDNABidiError("Label ends with illegal codepoint directionality")
>>>>>>> doua

    return True


def check_initial_combiner(label: str) -> bool:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    if unicodedata.category(label[0])[0] == "M":
        raise IDNAError("Label begins with an illegal combining character")
=======
    if unicodedata.category(label[0])[0] == 'M':
        raise IDNAError('Label begins with an illegal combining character')
>>>>>>> Stashed changes
=======
    if unicodedata.category(label[0])[0] == 'M':
        raise IDNAError('Label begins with an illegal combining character')
>>>>>>> doua
=======
    if unicodedata.category(label[0])[0] == "M":
        raise IDNAError("Label begins with an illegal combining character")
>>>>>>> doua
    return True


def check_hyphen_ok(label: str) -> bool:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
=======
>>>>>>> doua
    if label[2:4] == "--":
        raise IDNAError("Label has disallowed hyphens in 3rd and 4th position")
    if label[0] == "-" or label[-1] == "-":
        raise IDNAError("Label must not start or end with a hyphen")
<<<<<<< HEAD
=======
=======
>>>>>>> doua
    if label[2:4] == '--':
        raise IDNAError('Label has disallowed hyphens in 3rd and 4th position')
    if label[0] == '-' or label[-1] == '-':
        raise IDNAError('Label must not start or end with a hyphen')
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
>>>>>>> doua
    return True


def check_nfc(label: str) -> None:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    if unicodedata.normalize("NFC", label) != label:
        raise IDNAError("Label must be in Normalization Form C")
=======
    if unicodedata.normalize('NFC', label) != label:
        raise IDNAError('Label must be in Normalization Form C')
>>>>>>> Stashed changes
=======
    if unicodedata.normalize('NFC', label) != label:
        raise IDNAError('Label must be in Normalization Form C')
>>>>>>> doua
=======
    if unicodedata.normalize("NFC", label) != label:
        raise IDNAError("Label must be in Normalization Form C")
>>>>>>> doua


def valid_contextj(label: str, pos: int) -> bool:
    cp_value = ord(label[pos])

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    if cp_value == 0x200C:
=======
    if cp_value == 0x200c:

>>>>>>> Stashed changes
=======
    if cp_value == 0x200c:

>>>>>>> doua
=======
    if cp_value == 0x200C:
>>>>>>> doua
        if pos > 0:
            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
                return True

        ok = False
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        for i in range(pos - 1, -1, -1):
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
            elif joining_type in [ord("L"), ord("D")]:
=======
=======
>>>>>>> doua
        for i in range(pos-1, -1, -1):
=======
        for i in range(pos - 1, -1, -1):
>>>>>>> doua
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
<<<<<<< HEAD
<<<<<<< HEAD
            elif joining_type in [ord('L'), ord('D')]:
>>>>>>> Stashed changes
                ok = True
                break
            else:
                break
=======
            if joining_type in [ord('L'), ord('D')]:
                ok = True
                break
>>>>>>> doua
=======
            elif joining_type in [ord("L"), ord("D")]:
                ok = True
                break
            else:
                break
>>>>>>> doua

        if not ok:
            return False

        ok = False
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        for i in range(pos + 1, len(label)):
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
            elif joining_type in [ord("R"), ord("D")]:
=======
=======
>>>>>>> doua
        for i in range(pos+1, len(label)):
=======
        for i in range(pos + 1, len(label)):
>>>>>>> doua
            joining_type = idnadata.joining_types.get(ord(label[i]))
            if joining_type == ord("T"):
                continue
<<<<<<< HEAD
<<<<<<< HEAD
            elif joining_type in [ord('R'), ord('D')]:
>>>>>>> Stashed changes
                ok = True
                break
            else:
                break
        return ok

<<<<<<< Updated upstream
    if cp_value == 0x200D:
=======
    if cp_value == 0x200d:

>>>>>>> Stashed changes
=======
            if joining_type in [ord('R'), ord('D')]:
=======
            elif joining_type in [ord("R"), ord("D")]:
>>>>>>> doua
                ok = True
                break
            else:
                break
        return ok

<<<<<<< HEAD
    if cp_value == 0x200d:

>>>>>>> doua
=======
    if cp_value == 0x200D:
>>>>>>> doua
        if pos > 0:
            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:
                return True
        return False

    else:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
=======

>>>>>>> doua
=======
>>>>>>> doua
        return False


def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:
    cp_value = ord(label[pos])

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    if cp_value == 0x00B7:
        if 0 < pos < len(label) - 1:
            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:
=======
    if cp_value == 0x00b7:
        if 0 < pos < len(label)-1:
            if ord(label[pos - 1]) == 0x006c and ord(label[pos + 1]) == 0x006c:
>>>>>>> Stashed changes
=======
    if cp_value == 0x00b7:
        if 0 < pos < len(label)-1:
            if ord(label[pos - 1]) == 0x006c and ord(label[pos + 1]) == 0x006c:
>>>>>>> doua
=======
    if cp_value == 0x00B7:
        if 0 < pos < len(label) - 1:
            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:
>>>>>>> doua
                return True
        return False

    elif cp_value == 0x0375:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        if pos < len(label) - 1 and len(label) > 1:
            return _is_script(label[pos + 1], "Greek")
        return False

    elif cp_value == 0x05F3 or cp_value == 0x05F4:
        if pos > 0:
            return _is_script(label[pos - 1], "Hebrew")
        return False

    elif cp_value == 0x30FB:
        for cp in label:
            if cp == "\u30fb":
                continue
            if _is_script(cp, "Hiragana") or _is_script(cp, "Katakana") or _is_script(cp, "Han"):
=======
=======
>>>>>>> doua
        if pos < len(label)-1 and len(label) > 1:
            return _is_script(label[pos + 1], 'Greek')
=======
        if pos < len(label) - 1 and len(label) > 1:
            return _is_script(label[pos + 1], "Greek")
>>>>>>> doua
        return False

    elif cp_value == 0x05F3 or cp_value == 0x05F4:
        if pos > 0:
            return _is_script(label[pos - 1], "Hebrew")
        return False

    elif cp_value == 0x30FB:
        for cp in label:
            if cp == "\u30fb":
                continue
<<<<<<< HEAD
            if _is_script(cp, 'Hiragana') or _is_script(cp, 'Katakana') or _is_script(cp, 'Han'):
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
            if _is_script(cp, "Hiragana") or _is_script(cp, "Katakana") or _is_script(cp, "Han"):
>>>>>>> doua
                return True
        return False

    elif 0x660 <= cp_value <= 0x669:
        for cp in label:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
            if 0x6F0 <= ord(cp) <= 0x06F9:
                return False
        return True

    elif 0x6F0 <= cp_value <= 0x6F9:
=======
=======
>>>>>>> doua
            if 0x6f0 <= ord(cp) <= 0x06f9:
                return False
        return True

    elif 0x6f0 <= cp_value <= 0x6f9:
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
            if 0x6F0 <= ord(cp) <= 0x06F9:
                return False
        return True

    elif 0x6F0 <= cp_value <= 0x6F9:
>>>>>>> doua
        for cp in label:
            if 0x660 <= ord(cp) <= 0x0669:
                return False
        return True

    return False


def check_label(label: Union[str, bytes, bytearray]) -> None:
    if isinstance(label, (bytes, bytearray)):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        label = label.decode("utf-8")
    if len(label) == 0:
        raise IDNAError("Empty Label")
=======
        label = label.decode('utf-8')
    if len(label) == 0:
        raise IDNAError('Empty Label')
>>>>>>> Stashed changes
=======
        label = label.decode('utf-8')
    if len(label) == 0:
        raise IDNAError('Empty Label')
>>>>>>> doua
=======
        label = label.decode("utf-8")
    if len(label) == 0:
        raise IDNAError("Empty Label")
>>>>>>> doua

    check_nfc(label)
    check_hyphen_ok(label)
    check_initial_combiner(label)

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
    for pos, cp in enumerate(label):
        cp_value = ord(cp)
        if intranges_contain(cp_value, idnadata.codepoint_classes["PVALID"]):
            continue
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTJ"]):
            try:
                if not valid_contextj(label, pos):
                    raise InvalidCodepointContext(
                        "Joiner {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                    )
            except ValueError:
                raise IDNAError(
                    "Unknown codepoint adjacent to joiner {} at position {} in {}".format(
                        _unot(cp_value), pos + 1, repr(label)
                    )
                )
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTO"]):
            if not valid_contexto(label, pos):
                raise InvalidCodepointContext(
                    "Codepoint {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                )
        else:
            raise InvalidCodepoint(
                "Codepoint {} at position {} of {} not allowed".format(_unot(cp_value), pos + 1, repr(label))
            )
=======
=======
>>>>>>> doua
    for (pos, cp) in enumerate(label):
=======
    for pos, cp in enumerate(label):
>>>>>>> doua
        cp_value = ord(cp)
        if intranges_contain(cp_value, idnadata.codepoint_classes["PVALID"]):
            continue
<<<<<<< HEAD
        elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTJ']):
<<<<<<< HEAD
            if not valid_contextj(label, pos):
                raise InvalidCodepointContext('Joiner {} not allowed at position {} in {}'.format(
=======
=======
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTJ"]):
>>>>>>> doua
            try:
                if not valid_contextj(label, pos):
                    raise InvalidCodepointContext(
                        "Joiner {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                    )
            except ValueError:
<<<<<<< HEAD
                raise IDNAError('Unknown codepoint adjacent to joiner {} at position {} in {}'.format(
>>>>>>> doua
                    _unot(cp_value), pos+1, repr(label)))
        elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTO']):
=======
                raise IDNAError(
                    "Unknown codepoint adjacent to joiner {} at position {} in {}".format(
                        _unot(cp_value), pos + 1, repr(label)
                    )
                )
        elif intranges_contain(cp_value, idnadata.codepoint_classes["CONTEXTO"]):
>>>>>>> doua
            if not valid_contexto(label, pos):
                raise InvalidCodepointContext(
                    "Codepoint {} not allowed at position {} in {}".format(_unot(cp_value), pos + 1, repr(label))
                )
        else:
<<<<<<< HEAD
            raise InvalidCodepoint('Codepoint {} at position {} of {} not allowed'.format(_unot(cp_value), pos+1, repr(label)))
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
            raise InvalidCodepoint(
                "Codepoint {} at position {} of {} not allowed".format(_unot(cp_value), pos + 1, repr(label))
            )
>>>>>>> doua

    check_bidi(label)


def alabel(label: str) -> bytes:
    try:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        label_bytes = label.encode("ascii")
        ulabel(label_bytes)
        if not valid_label_length(label_bytes):
            raise IDNAError("Label too long")
=======
=======
>>>>>>> doua
        label_bytes = label.encode('ascii')
        ulabel(label_bytes)
        if not valid_label_length(label_bytes):
            raise IDNAError('Label too long')
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
        label_bytes = label.encode("ascii")
        ulabel(label_bytes)
        if not valid_label_length(label_bytes):
            raise IDNAError("Label too long")
>>>>>>> doua
        return label_bytes
    except UnicodeEncodeError:
        pass

<<<<<<< HEAD
<<<<<<< HEAD
    check_label(label)
    label_bytes = _alabel_prefix + _punycode(label)

    if not valid_label_length(label_bytes):
<<<<<<< Updated upstream
        raise IDNAError("Label too long")
=======
        raise IDNAError('Label too long')
>>>>>>> Stashed changes
=======
    if not label:
        raise IDNAError('No Input')

    label = str(label)
=======
>>>>>>> doua
    check_label(label)
    label_bytes = _alabel_prefix + _punycode(label)

    if not valid_label_length(label_bytes):
<<<<<<< HEAD
        raise IDNAError('Label too long')
>>>>>>> doua
=======
        raise IDNAError("Label too long")
>>>>>>> doua

    return label_bytes


def ulabel(label: Union[str, bytes, bytearray]) -> str:
    if not isinstance(label, (bytes, bytearray)):
        try:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
            label_bytes = label.encode("ascii")
=======
            label_bytes = label.encode('ascii')
>>>>>>> Stashed changes
=======
            label_bytes = label.encode('ascii')
>>>>>>> doua
=======
            label_bytes = label.encode("ascii")
>>>>>>> doua
        except UnicodeEncodeError:
            check_label(label)
            return label
    else:
        label_bytes = label

    label_bytes = label_bytes.lower()
    if label_bytes.startswith(_alabel_prefix):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        label_bytes = label_bytes[len(_alabel_prefix) :]
        if not label_bytes:
            raise IDNAError("Malformed A-label, no Punycode eligible content found")
        if label_bytes.decode("ascii")[-1] == "-":
            raise IDNAError("A-label must not end with a hyphen")
    else:
        check_label(label_bytes)
        return label_bytes.decode("ascii")

    try:
        label = label_bytes.decode("punycode")
    except UnicodeError:
        raise IDNAError("Invalid A-label")
=======
=======
>>>>>>> doua
        label_bytes = label_bytes[len(_alabel_prefix):]
=======
        label_bytes = label_bytes[len(_alabel_prefix) :]
>>>>>>> doua
        if not label_bytes:
            raise IDNAError("Malformed A-label, no Punycode eligible content found")
        if label_bytes.decode("ascii")[-1] == "-":
            raise IDNAError("A-label must not end with a hyphen")
    else:
        check_label(label_bytes)
        return label_bytes.decode("ascii")

    try:
        label = label_bytes.decode("punycode")
    except UnicodeError:
<<<<<<< HEAD
        raise IDNAError('Invalid A-label')
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
        raise IDNAError("Invalid A-label")
>>>>>>> doua
    check_label(label)
    return label


def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:
    """Re-map the characters in the string according to UTS46 processing."""
    from .uts46data import uts46data
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream

    output = ""
=======
    output = ''
>>>>>>> Stashed changes
=======
    output = ''
>>>>>>> doua
=======

    output = ""
>>>>>>> doua

    for pos, char in enumerate(domain):
        code_point = ord(char)
        try:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, "Z")) - 1]
            status = uts46row[1]
            replacement: Optional[str] = None
            if len(uts46row) == 3:
                replacement = uts46row[2]
            if (
                status == "V"
                or (status == "D" and not transitional)
                or (status == "3" and not std3_rules and replacement is None)
            ):
                output += char
            elif replacement is not None and (
                status == "M" or (status == "3" and not std3_rules) or (status == "D" and transitional)
            ):
                output += replacement
            elif status != "I":
                raise IndexError()
        except IndexError:
            raise InvalidCodepoint(
                "Codepoint {} not allowed at position {} in {}".format(_unot(code_point), pos + 1, repr(domain))
            )

    return unicodedata.normalize("NFC", output)


def encode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
    transitional: bool = False,
) -> bytes:
    if not isinstance(s, str):
        try:
            s = str(s, "ascii")
        except UnicodeDecodeError:
            raise IDNAError("should pass a unicode string to the function rather than a byte string.")
=======
=======
>>>>>>> doua
            uts46row = uts46data[code_point if code_point < 256 else
                bisect.bisect_left(uts46data, (code_point, 'Z')) - 1]
=======
            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, "Z")) - 1]
>>>>>>> doua
            status = uts46row[1]
            replacement: Optional[str] = None
            if len(uts46row) == 3:
<<<<<<< HEAD
<<<<<<< HEAD
                replacement = uts46row[2]
=======
                replacement = uts46row[2]  # type: ignore
>>>>>>> doua
            if (status == 'V' or
                    (status == 'D' and not transitional) or
                    (status == '3' and not std3_rules and replacement is None)):
=======
                replacement = uts46row[2]
            if (
                status == "V"
                or (status == "D" and not transitional)
                or (status == "3" and not std3_rules and replacement is None)
            ):
>>>>>>> doua
                output += char
            elif replacement is not None and (
                status == "M" or (status == "3" and not std3_rules) or (status == "D" and transitional)
            ):
                output += replacement
            elif status != "I":
                raise IndexError()
        except IndexError:
            raise InvalidCodepoint(
                "Codepoint {} not allowed at position {} in {}".format(_unot(code_point), pos + 1, repr(domain))
            )

    return unicodedata.normalize("NFC", output)


<<<<<<< HEAD
def encode(s: Union[str, bytes, bytearray], strict: bool = False, uts46: bool = False, std3_rules: bool = False, transitional: bool = False) -> bytes:
<<<<<<< HEAD
    if not isinstance(s, str):
        try:
            s = str(s, 'ascii')
        except UnicodeDecodeError:
            raise IDNAError('should pass a unicode string to the function rather than a byte string.')
>>>>>>> Stashed changes
=======
    if isinstance(s, (bytes, bytearray)):
=======
def encode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
    transitional: bool = False,
) -> bytes:
    if not isinstance(s, str):
>>>>>>> doua
        try:
            s = str(s, "ascii")
        except UnicodeDecodeError:
<<<<<<< HEAD
            raise IDNAError('should pass a unicode string to the function rather than a byte string.')
>>>>>>> doua
=======
            raise IDNAError("should pass a unicode string to the function rather than a byte string.")
>>>>>>> doua
    if uts46:
        s = uts46_remap(s, std3_rules, transitional)
    trailing_dot = False
    result = []
    if strict:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        labels = s.split(".")
    else:
        labels = _unicode_dots_re.split(s)
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
    if labels[-1] == "":
=======
=======
>>>>>>> doua
        labels = s.split('.')
    else:
        labels = _unicode_dots_re.split(s)
    if not labels or labels == ['']:
        raise IDNAError('Empty domain')
    if labels[-1] == '':
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
        labels = s.split(".")
    else:
        labels = _unicode_dots_re.split(s)
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
    if labels[-1] == "":
>>>>>>> doua
        del labels[-1]
        trailing_dot = True
    for label in labels:
        s = alabel(label)
        if s:
            result.append(s)
        else:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
            raise IDNAError("Empty label")
    if trailing_dot:
        result.append(b"")
    s = b".".join(result)
    if not valid_string_length(s, trailing_dot):
        raise IDNAError("Domain too long")
    return s


def decode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
) -> str:
    try:
        if not isinstance(s, str):
            s = str(s, "ascii")
    except UnicodeDecodeError:
        raise IDNAError("Invalid ASCII in A-label")
=======
=======
>>>>>>> doua
            raise IDNAError('Empty label')
=======
            raise IDNAError("Empty label")
>>>>>>> doua
    if trailing_dot:
        result.append(b"")
    s = b".".join(result)
    if not valid_string_length(s, trailing_dot):
        raise IDNAError("Domain too long")
    return s


def decode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
) -> str:
    try:
<<<<<<< HEAD
<<<<<<< HEAD
        if not isinstance(s, str):
            s = str(s, 'ascii')
    except UnicodeDecodeError:
        raise IDNAError('Invalid ASCII in A-label')
>>>>>>> Stashed changes
=======
        if isinstance(s, (bytes, bytearray)):
            s = s.decode('ascii')
    except UnicodeDecodeError:
        raise IDNAError('Invalid ASCII in A-label')
>>>>>>> doua
=======
        if not isinstance(s, str):
            s = str(s, "ascii")
    except UnicodeDecodeError:
        raise IDNAError("Invalid ASCII in A-label")
>>>>>>> doua
    if uts46:
        s = uts46_remap(s, std3_rules, False)
    trailing_dot = False
    result = []
    if not strict:
        labels = _unicode_dots_re.split(s)
    else:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
        labels = s.split(".")
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
=======
        labels = s.split('.')
    if not labels or labels == ['']:
        raise IDNAError('Empty domain')
>>>>>>> Stashed changes
=======
        labels = s.split('.')
    if not labels or labels == ['']:
        raise IDNAError('Empty domain')
>>>>>>> doua
=======
        labels = s.split(".")
    if not labels or labels == [""]:
        raise IDNAError("Empty domain")
>>>>>>> doua
    if not labels[-1]:
        del labels[-1]
        trailing_dot = True
    for label in labels:
        s = ulabel(label)
        if s:
            result.append(s)
        else:
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< Updated upstream
            raise IDNAError("Empty label")
    if trailing_dot:
        result.append("")
    return ".".join(result)
=======
=======
>>>>>>> doua
            raise IDNAError('Empty label')
    if trailing_dot:
        result.append('')
    return '.'.join(result)
<<<<<<< HEAD
>>>>>>> Stashed changes
=======
>>>>>>> doua
=======
            raise IDNAError("Empty label")
    if trailing_dot:
        result.append("")
    return ".".join(result)
>>>>>>> doua
